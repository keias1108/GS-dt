<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Gray-Scott + dt(temperature) hierarchy (single HTML)</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #0b0e14;
        color: #e7eefc;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
      }
      .wrap {
        display: grid;
        grid-template-columns: 1fr 340px;
        gap: 12px;
        height: 100%;
        padding: 12px;
        box-sizing: border-box;
      }
      canvas {
        width: 100%;
        height: 100%;
        background: #000;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
      }
      .panel {
        background: #111827;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 12px;
        overflow: auto;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
      }
      .row label {
        font-size: 12px;
        color: #cbd5e1;
      }
      input[type="range"] {
        width: 100%;
      }
      input[type="number"],
      select {
        width: 120px;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.12);
        color: #e7eefc;
        border-radius: 8px;
        padding: 6px;
      }
      button {
        background: #2563eb;
        border: none;
        color: #fff;
        border-radius: 10px;
        padding: 10px 12px;
        font-weight: 700;
        cursor: pointer;
      }
      button.secondary {
        background: #334155;
      }
      button.danger {
        background: #b91c1c;
      }
      .hint {
        font-size: 12px;
        color: #94a3b8;
        line-height: 1.35;
        margin-top: 8px;
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.12);
        font-size: 11px;
        color: #cbd5e1;
      }
      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .hr {
        height: 1px;
        background: rgba(255, 255, 255, 0.08);
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <canvas id="c"></canvas>

      <div class="panel">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
          "
        >
          <div>
            <div style="font-weight: 800; font-size: 14px">
              Gray–Scott + dt 계층(온도)
            </div>
            <div class="hint">
              에너지(활동도)↑ → dt↓(빠른 미시), 에너지↓ → dt↑(느린 거시/‘굳음’)
            </div>
          </div>
          <span class="badge" id="fps">FPS: -</span>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <button id="runBtn">▶ Run</button>
          <button class="secondary" id="stepBtn">Step</button>
          <button class="secondary" id="seedBtn">Reseed</button>
          <button class="danger" id="clearBtn">Clear</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <label>View</label>
          <select id="viewSel">
            <option value="V">V (pattern)</option>
            <option value="U">U</option>
            <option value="dt">dt map</option>
            <option value="E">energy map</option>
          </select>
        </div>

        <div class="row">
          <label>Energy metric</label>
          <select id="energySel">
            <option value="react">E = U·V² (reaction)</option>
            <option value="grad">E = |∇U|² + |∇V|² (structure)</option>
            <option value="time">E = |dU| + |dV| (activity)</option>
            <option value="mix">Mix (0.5 react + 0.5 grad)</option>
          </select>
        </div>

        <div class="row">
          <label>Mix α (only for Mix)</label>
          <input
            id="mixA"
            type="range"
            min="0"
            max="1"
            step="0.01"
            value="0.5"
          />
          <span id="mixATxt" class="badge">0.50</span>
        </div>

        <div class="hr"></div>

        <div class="row">
          <label>Du</label>
          <input
            id="du"
            type="range"
            min="0"
            max="1"
            step="0.001"
            value="0.16"
          />
          <span id="duTxt" class="badge">0.160</span>
        </div>
        <div class="row">
          <label>Dv</label>
          <input
            id="dv"
            type="range"
            min="0"
            max="1"
            step="0.001"
            value="0.08"
          />
          <span id="dvTxt" class="badge">0.080</span>
        </div>

        <div class="row">
          <label>Feed (F)</label>
          <input
            id="F"
            type="range"
            min="0"
            max="0.08"
            step="0.0001"
            value="0.035"
          />
          <span id="FTxt" class="badge">0.0350</span>
        </div>
        <div class="row">
          <label>Kill (k)</label>
          <input
            id="k"
            type="range"
            min="0"
            max="0.08"
            step="0.0001"
            value="0.060"
          />
          <span id="kTxt" class="badge">0.0600</span>
        </div>

        <div class="hr"></div>

        <div class="row">
          <label>dt_min</label>
          <input id="dtMin" type="number" step="0.001" value="0.20" />
        </div>
        <div class="row">
          <label>dt_max</label>
          <input id="dtMax" type="number" step="0.001" value="1.50" />
        </div>

        <div class="row">
          <label>Temp scale (T)</label>
          <input
            id="temp"
            type="range"
            min="0.001"
            max="1"
            step="0.001"
            value="0.08"
          />
          <span id="tempTxt" class="badge">0.080</span>
        </div>

        <div class="row">
          <label>Energy EMA (smoothing)</label>
          <input
            id="ema"
            type="range"
            min="0"
            max="0.99"
            step="0.01"
            value="0.80"
          />
          <span id="emaTxt" class="badge">0.80</span>
        </div>

        <div class="row">
          <label>Steps / frame</label>
          <input id="spf" type="range" min="1" max="20" step="1" value="6" />
          <span id="spfTxt" class="badge">6</span>
        </div>

        <div class="row">
          <label>Brush (mouse)</label>
          <select id="brushSel">
            <option value="V">Add V</option>
            <option value="U">Add U</option>
            <option value="UV">Add both</option>
            <option value="erase">Erase (reset to U=1,V=0)</option>
          </select>
        </div>

        <div class="row">
          <label>Brush radius</label>
          <input id="br" type="range" min="1" max="40" step="1" value="10" />
          <span id="brTxt" class="badge">10</span>
        </div>

        <div class="hint">
          <b>“계층 느낌” 체크 포인트</b><br />
          1) View를 <span class="badge">dt map</span>으로 바꿔서 ‘차가운(큰 dt)’
          영역이 패턴의 “굳은 흔적”과 겹치는지 보기<br />
          2) Feed/kill을 조금씩 바꿨을 때, 일부 구조가 더 오래 남거나 느리게
          변하면 dt-계층이 먹힌 것<br />
          3) <span class="badge">energy=grad</span> 또는
          <span class="badge">mix</span>가 “객체화(경계/지형)”에 더 유리한 편
        </div>
      </div>
    </div>

    <script>
      (() => {
        // ====== Config ======
        const W = 220,
          H = 220;
        const N = W * H;

        // Gray-Scott parameters (defaults)
        let Du = 0.16,
          Dv = 0.08,
          F = 0.035,
          K = 0.06;

        // dt hierarchy parameters
        let dtMin = 0.2,
          dtMax = 1.5;
        let tempScale = 0.08; // T in exp(-E/T)
        let emaAlpha = 0.8; // energy smoothing (0..0.99)
        let stepsPerFrame = 6;

        // energy metric controls
        let energyMode = "react";
        let mixAlpha = 0.5;

        // ====== State buffers ======
        // U,V ping-pong
        let U0 = new Float32Array(N);
        let V0 = new Float32Array(N);
        let U1 = new Float32Array(N);
        let V1 = new Float32Array(N);

        // For energy and dt
        let Eraw = new Float32Array(N);
        let Eema = new Float32Array(N);
        let dtMap = new Float32Array(N);

        // For activity metric (time)
        let dU = new Float32Array(N);
        let dV = new Float32Array(N);

        // ====== Canvas ======
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d", { alpha: false });
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        function resize() {
          const r = canvas.getBoundingClientRect();
          canvas.width = Math.floor(r.width * dpr);
          canvas.height = Math.floor(r.height * dpr);
        }
        window.addEventListener("resize", resize);
        resize();

        // Offscreen image for rendering
        const img = ctx.createImageData(W, H);
        const pix = img.data;

        // ====== Utilities ======
        const clamp = (x, a, b) => (x < a ? a : x > b ? b : x);
        const idx = (x, y) => x + y * W;
        const wrap = (x, m) => (x + m) % m;

        function laplacian(A, x, y) {
          // 5-point stencil with wrap
          const xm = wrap(x - 1, W),
            xp = wrap(x + 1, W);
          const ym = wrap(y - 1, H),
            yp = wrap(y + 1, H);
          const c = A[idx(x, y)];
          const l = A[idx(xm, y)];
          const r = A[idx(xp, y)];
          const u = A[idx(x, ym)];
          const d = A[idx(x, yp)];
          return l + r + u + d - 4 * c;
        }

        function gradEnergy(U, V, x, y) {
          // simple squared gradient via central diffs
          const xm = wrap(x - 1, W),
            xp = wrap(x + 1, W);
          const ym = wrap(y - 1, H),
            yp = wrap(y + 1, H);
          const ux = 0.5 * (U[idx(xp, y)] - U[idx(xm, y)]);
          const uy = 0.5 * (U[idx(x, yp)] - U[idx(x, ym)]);
          const vx = 0.5 * (V[idx(xp, y)] - V[idx(xm, y)]);
          const vy = 0.5 * (V[idx(x, yp)] - V[idx(x, ym)]);
          return ux * ux + uy * uy + vx * vx + vy * vy;
        }

        function computeEnergy(U, V) {
          // Fill Eraw from selected metric
          if (energyMode === "react") {
            for (let i = 0; i < N; i++) {
              const u = U[i],
                v = V[i];
              Eraw[i] = u * v * v; // U*V^2
            }
          } else if (energyMode === "time") {
            for (let i = 0; i < N; i++) {
              Eraw[i] = Math.abs(dU[i]) + Math.abs(dV[i]);
            }
          } else if (energyMode === "grad") {
            for (let y = 0; y < H; y++) {
              for (let x = 0; x < W; x++) {
                Eraw[idx(x, y)] = gradEnergy(U, V, x, y);
              }
            }
          } else if (energyMode === "mix") {
            // mix of react + grad
            // react part:
            for (let i = 0; i < N; i++) {
              const u = U[i],
                v = V[i];
              Eraw[i] = u * v * v; // temp store react in Eraw
            }
            // compute grad in-place into temp array
            // we’ll reuse dtMap temporarily as G
            for (let y = 0; y < H; y++) {
              for (let x = 0; x < W; x++) {
                dtMap[idx(x, y)] = gradEnergy(U, V, x, y);
              }
            }
            const a = mixAlpha;
            for (let i = 0; i < N; i++) {
              Eraw[i] = a * Eraw[i] + (1 - a) * dtMap[i];
            }
          }

          // EMA smooth
          const a = emaAlpha;
          const ia = 1 - a;
          for (let i = 0; i < N; i++) {
            Eema[i] = a * Eema[i] + ia * Eraw[i];
          }
        }

        function buildDtMap() {
          // Map energy -> dt (hot => smaller dt, cold => larger dt)
          // dt = dtMin + (dtMax-dtMin) * exp(-E/T)
          // Normalize-ish: energy magnitude varies wildly by metric. We do a robust scaling using percentile-ish clamp.
          // We'll compute a quick max (not perfect) and clamp.
          let eMax = 0;
          for (let i = 0; i < N; i++) eMax = Math.max(eMax, Eema[i]);
          // Avoid zero division; also keep stable if eMax spikes
          const scale = eMax > 1e-8 ? 1 / eMax : 1.0;

          const span = dtMax - dtMin;
          const T = Math.max(1e-6, tempScale);
          for (let i = 0; i < N; i++) {
            // normalized energy in [0,1] (rough)
            const e = clamp(Eema[i] * scale, 0, 1);
            const dt = dtMin + span * Math.exp(-e / T);
            dtMap[i] = clamp(
              dt,
              Math.min(dtMin, dtMax),
              Math.max(dtMin, dtMax)
            );
          }
        }

        function seed() {
          // Start near U=1,V=0 with a disturbed patch of V
          U0.fill(1);
          V0.fill(0);
          U1.fill(1);
          V1.fill(0);
          Eraw.fill(0);
          Eema.fill(0);
          dtMap.fill(dtMax);
          dU.fill(0);
          dV.fill(0);

          const cx = Math.floor(W / 2),
            cy = Math.floor(H / 2);
          for (let y = cy - 12; y <= cy + 12; y++) {
            for (let x = cx - 12; x <= cx + 12; x++) {
              const xx = wrap(x, W),
                yy = wrap(y, H);
              V0[idx(xx, yy)] = 1.0;
              U0[idx(xx, yy)] = 0.0;
            }
          }
        }

        function clearAll() {
          U0.fill(1);
          V0.fill(0);
          U1.fill(1);
          V1.fill(0);
          Eraw.fill(0);
          Eema.fill(0);
          dtMap.fill(dtMax);
          dU.fill(0);
          dV.fill(0);
        }

        seed();

        // ====== Simulation step ======
        function stepOnce() {
          // Compute energy from current state (U0,V0) and update dtMap
          computeEnergy(U0, V0);
          buildDtMap();

          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              const i = idx(x, y);
              const u = U0[i];
              const v = V0[i];

              const Lu = laplacian(U0, x, y);
              const Lv = laplacian(V0, x, y);

              const uvv = u * v * v;

              // Gray-Scott reaction terms
              // du/dt = Du*Lap(u) - u*v*v + F*(1-u)
              // dv/dt = Dv*Lap(v) + u*v*v - (F+K)*v
              const du_dt = Du * Lu - uvv + F * (1 - u);
              const dv_dt = Dv * Lv + uvv - (F + K) * v;

              const dt = dtMap[i];

              const un = u + dt * du_dt;
              const vn = v + dt * dv_dt;

              U1[i] = clamp(un, 0, 1);
              V1[i] = clamp(vn, 0, 1);

              dU[i] = U1[i] - u; // for activity metric (time)
              dV[i] = V1[i] - v;
            }
          }

          // swap
          let t = U0;
          U0 = U1;
          U1 = t;
          t = V0;
          V0 = V1;
          V1 = t;
        }

        // ====== Rendering ======
        function render() {
          const view = document.getElementById("viewSel").value;

          // Find min/max for dt/E view mapping
          let vMin = 1e9,
            vMax = -1e9;
          if (view === "dt") {
            for (let i = 0; i < N; i++) {
              vMin = Math.min(vMin, dtMap[i]);
              vMax = Math.max(vMax, dtMap[i]);
            }
            if (!(vMax > vMin)) {
              vMin = 0;
              vMax = 1;
            }
          } else if (view === "E") {
            for (let i = 0; i < N; i++) {
              vMin = Math.min(vMin, Eema[i]);
              vMax = Math.max(vMax, Eema[i]);
            }
            if (!(vMax > vMin)) {
              vMin = 0;
              vMax = 1;
            }
          }

          for (let i = 0; i < N; i++) {
            let v = 0;
            if (view === "V") v = V0[i];
            else if (view === "U") v = U0[i];
            else if (view === "dt") v = (dtMap[i] - vMin) / (vMax - vMin);
            else if (view === "E") v = (Eema[i] - vMin) / (vMax - vMin);

            v = clamp(v, 0, 1);

            // simple perceptual-ish mapping: grayscale
            const c = Math.floor(v * 255);
            const p = i * 4;
            pix[p] = c;
            pix[p + 1] = c;
            pix[p + 2] = c;
            pix[p + 3] = 255;
          }

          // draw scaled to canvas
          // nearest-neighbor look for crispness (and speed)
          const off = document.createElement("canvas");
          off.width = W;
          off.height = H;
          off.getContext("2d").putImageData(img, 0, 0);

          ctx.imageSmoothingEnabled = false;
          const cw = canvas.width,
            ch = canvas.height;
          ctx.clearRect(0, 0, cw, ch);

          // fit square
          const s = Math.min(cw, ch);
          const ox = (cw - s) / 2;
          const oy = (ch - s) / 2;
          ctx.drawImage(off, 0, 0, W, H, ox, oy, s, s);
        }

        // ====== UI Wiring ======
        const bindRange = (id, fmt, onChange) => {
          const el = document.getElementById(id);
          const txt = document.getElementById(id + "Txt");
          const update = () => {
            txt.textContent = fmt(parseFloat(el.value));
            onChange(parseFloat(el.value));
          };
          el.addEventListener("input", update);
          update();
        };

        bindRange(
          "du",
          (v) => v.toFixed(3),
          (v) => (Du = v)
        );
        bindRange(
          "dv",
          (v) => v.toFixed(3),
          (v) => (Dv = v)
        );
        bindRange(
          "F",
          (v) => v.toFixed(4),
          (v) => (F = v)
        );
        bindRange(
          "k",
          (v) => v.toFixed(4),
          (v) => (K = v)
        );
        bindRange(
          "temp",
          (v) => v.toFixed(3),
          (v) => (tempScale = v)
        );
        bindRange(
          "ema",
          (v) => v.toFixed(2),
          (v) => (emaAlpha = v)
        );
        bindRange(
          "spf",
          (v) => String(v | 0),
          (v) => (stepsPerFrame = v | 0)
        );

        const mixAEl = document.getElementById("mixA");
        const mixATxt = document.getElementById("mixATxt");
        mixAEl.addEventListener("input", () => {
          mixAlpha = parseFloat(mixAEl.value);
          mixATxt.textContent = mixAlpha.toFixed(2);
        });
        mixAlpha = parseFloat(mixAEl.value);
        mixATxt.textContent = mixAlpha.toFixed(2);

        const energySel = document.getElementById("energySel");
        energySel.addEventListener("change", () => {
          energyMode = energySel.value;
        });
        energyMode = energySel.value;

        const dtMinEl = document.getElementById("dtMin");
        const dtMaxEl = document.getElementById("dtMax");
        function updateDtBounds() {
          dtMin = parseFloat(dtMinEl.value);
          dtMax = parseFloat(dtMaxEl.value);
          if (!isFinite(dtMin)) dtMin = 0.2;
          if (!isFinite(dtMax)) dtMax = 1.5;
          // keep sane
          dtMin = clamp(dtMin, 0.001, 10);
          dtMax = clamp(dtMax, 0.001, 10);
        }
        dtMinEl.addEventListener("change", updateDtBounds);
        dtMaxEl.addEventListener("change", updateDtBounds);
        updateDtBounds();

        document.getElementById("seedBtn").addEventListener("click", seed);
        document.getElementById("clearBtn").addEventListener("click", clearAll);

        document.getElementById("stepBtn").addEventListener("click", () => {
          for (let i = 0; i < stepsPerFrame; i++) stepOnce();
          render();
        });

        // ====== Painting ======
        let painting = false;
        let brushRadius = 10;
        const brEl = document.getElementById("br");
        const brTxt = document.getElementById("brTxt");
        brEl.addEventListener("input", () => {
          brushRadius = parseInt(brEl.value, 10) | 0;
          brTxt.textContent = String(brushRadius);
        });
        brushRadius = parseInt(brEl.value, 10) | 0;
        brTxt.textContent = String(brushRadius);

        function canvasToGrid(e) {
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;

          // map to centered square view
          const s = Math.min(rect.width, rect.height);
          const ox = (rect.width - s) / 2;
          const oy = (rect.height - s) / 2;

          const sx = (e.clientX - rect.left - ox) / s;
          const sy = (e.clientY - rect.top - oy) / s;

          const gx = Math.floor(sx * W);
          const gy = Math.floor(sy * H);

          if (gx < 0 || gx >= W || gy < 0 || gy >= H) return null;
          return { gx, gy };
        }

        function paintAt(gx, gy) {
          const mode = document.getElementById("brushSel").value;
          const r = brushRadius;
          for (let yy = gy - r; yy <= gy + r; yy++) {
            for (let xx = gx - r; xx <= gx + r; xx++) {
              const dx = xx - gx,
                dy = yy - gy;
              if (dx * dx + dy * dy > r * r) continue;
              const x = wrap(xx, W),
                y = wrap(yy, H);
              const i = idx(x, y);
              if (mode === "erase") {
                U0[i] = 1.0;
                V0[i] = 0.0;
              } else if (mode === "V") {
                V0[i] = 1.0;
                U0[i] = 0.0;
              } else if (mode === "U") {
                U0[i] = 1.0; // already 1, but keep
                V0[i] = 0.0;
              } else if (mode === "UV") {
                U0[i] = 0.5;
                V0[i] = 0.5;
              }
            }
          }
        }

        canvas.addEventListener("pointerdown", (e) => {
          painting = true;
          const g = canvasToGrid(e);
          if (g) paintAt(g.gx, g.gy);
        });
        canvas.addEventListener("pointermove", (e) => {
          if (!painting) return;
          const g = canvasToGrid(e);
          if (g) paintAt(g.gx, g.gy);
        });
        window.addEventListener("pointerup", () => (painting = false));

        // ====== Run loop ======
        let running = false;
        const runBtn = document.getElementById("runBtn");
        runBtn.addEventListener("click", () => {
          running = !running;
          runBtn.textContent = running ? "⏸ Pause" : "▶ Run";
        });

        // FPS
        const fpsEl = document.getElementById("fps");
        let lastT = performance.now();
        let acc = 0,
          frames = 0;

        function tick() {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;
          acc += dt;
          frames++;
          if (acc >= 500) {
            const fps = (frames * 1000) / acc;
            fpsEl.textContent = "FPS: " + fps.toFixed(1);
            acc = 0;
            frames = 0;
          }

          if (running) {
            for (let i = 0; i < stepsPerFrame; i++) stepOnce();
          } else {
            // still update dtMap/energy sometimes so dt/E view isn't stale
            computeEnergy(U0, V0);
            buildDtMap();
          }

          render();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      })();
    </script>
  </body>
</html>
